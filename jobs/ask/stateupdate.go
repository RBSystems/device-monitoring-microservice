package ask

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"github.com/byuoitav/av-api/base"
	"github.com/byuoitav/common/log"
	"github.com/byuoitav/common/nerr"
	"github.com/byuoitav/common/v2/events"
	"github.com/byuoitav/device-monitoring/localsystem"
)

// StateUpdateJob is a job that gets the status of all the devices in the room, and pushes events from the status to "true up" the state of the room
type StateUpdateJob struct{}

// Run runs the job.
func (s *StateUpdateJob) Run(ctx interface{}, eventWrite chan events.Event) interface{} {
	log.L.Infof("Getting room status")

	split := strings.Split(localsystem.MustRoomID(), "-")
	resp, err := http.Get(fmt.Sprintf("http://localhost:8000/buildings/%v/rooms/%v", split[0], split[1]))
	if err != nil {
		return nerr.Translate(err).Addf("failed to get room status: %v", err)
	}
	defer resp.Body.Close()

	// read the body
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nerr.Translate(err).Addf("failed to read API status response: %v", err)
	}

	if resp.StatusCode/100 != 2 {
		return nerr.Create(fmt.Sprintf("non 200 response received after querying API status: %s", b), "")
	}

	var status base.PublicRoom
	err = json.Unmarshal(b, &status)
	if err != nil {
		return nerr.Translate(err).Addf("failed to unmarshal API status response: %v", err)
	}

	log.L.Infof("Successfully got room status")

	// build base event
	event := events.Event{
		GeneratingSystem: localsystem.MustHostname(),
		Timestamp:        time.Now(),
		EventTags: []string{
			events.CoreState,
			events.AutoGenerated,
		},
		AffectedRoom: events.GenerateBasicRoomInfo(localsystem.MustRoomID()),
	}

	sentDisplays := make(map[string]bool)

	// take the response and send events
	log.L.Debugf("Sending events for displays...")
	for _, dev := range status.Displays {
		if strings.Contains(dev.Name, "-") {
			event.TargetDevice = events.GenerateBasicDeviceInfo(dev.Name)
		} else {
			event.TargetDevice = events.GenerateBasicDeviceInfo(fmt.Sprintf("%v-%v", localsystem.MustRoomID(), dev.Name))
		}

		log.L.Debugf("Reporting status of %v", event.TargetDevice.DeviceID)

		// report power status
		if len(dev.Power) > 0 {
			event.Key = "power"
			event.Value = dev.Power
			eventWrite <- event
		}

		// report input status
		if len(dev.Input) > 0 {
			event.Key = "input"
			event.Value = dev.Input
			eventWrite <- event
		}

		// report blanked status
		if dev.Blanked != nil {
			event.Key = "blanked"
			event.Value = fmt.Sprintf("%v", *dev.Blanked)
			eventWrite <- event
		}

		sentDisplays[dev.Name] = true
	}

	log.L.Debugf("Sending events for audio devices...")
	for _, dev := range status.AudioDevices {
		if strings.Contains(dev.Name, "-") {
			event.TargetDevice = events.GenerateBasicDeviceInfo(dev.Name)
		} else {
			event.TargetDevice = events.GenerateBasicDeviceInfo(fmt.Sprintf("%v-%v", localsystem.MustRoomID(), dev.Name))
		}

		if dev.Muted != nil {
			event.Key = "muted"
			event.Value = fmt.Sprintf("%v", *dev.Muted)
			eventWrite <- event
		}

		if dev.Volume != nil {
			event.Key = "volume"
			event.Value = fmt.Sprintf("%v", *dev.Volume)
			eventWrite <- event
		}

		// send common info if it hasn't already been sent
		if _, ok := sentDisplays[dev.Name]; !ok {
			if len(dev.Power) > 0 {
				event.Key = "power"
				event.Value = dev.Power
				eventWrite <- event
			}

			if len(dev.Input) > 0 {
				event.Key = "input"
				event.Value = dev.Input
				eventWrite <- event
			}
		}
	}

	return status
}
