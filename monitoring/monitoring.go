package monitoring

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/byuoitav/av-api/base"
	"github.com/byuoitav/central-event-system/messenger"
	"github.com/byuoitav/common/events"
	"github.com/byuoitav/touchpanel-ui-microservice/uiconfig"
	"github.com/fatih/color"
)

var m *messenger.Messenger

//var eventnode *events.EventNode
var ticker time.Ticker

//StartMonitoring will start a routine that will periodically query the apiAddr, building, and room.
//The responses will be decoded into the state variables and reported to the elk stack as CORESTATE events, with AUTOGENERATED cause
func StartMonitoring(interval time.Duration, apiAddr string, building string, room string, m *messenger.Messenger) string {
	messenger = m
	addr := fmt.Sprintf("http://%s/buildings/%s/rooms/%s", apiAddr, building, room)
	ticker := time.NewTicker(interval)

	go func() {
		for _ = range ticker.C {
			log.Printf("[api-status] Getting and reporting status to %v", addr)
			err := GetAndReportStatus(addr, building, room)
			if err != nil {
				log.Printf("[api-status] Error reporting the status: %v", err.Error())
			}
			log.Printf("[api-status] Done.")
		}
	}()

	return addr
}
func StopMonitoring() {
	ticker.Stop()
}

func GetAndReportStatus(addr string, pbuilding string, proom string) error {
	log.Printf("[api-status] Getting status...")
	resp, err := http.Get(addr)
	if err != nil {
		errStr := fmt.Sprintf("There was a problem getting the response while querying room status: %v", err.Error())
		log.Printf("[api-status]" + errStr)
		PublishError(errStr, events.AutoGenerated)
		return err
	}

	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		b, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			errStr := fmt.Sprintf("There was a problem reading the response on a non-200 response: %v", err.Error())
			log.Printf("[api-status]" + errStr)
			PublishError(errStr, events.AUTOGENERATED)
			return err
		}
		errStr := fmt.Sprintf("Non 200 response recieved: %s", b)
		log.Printf("[api-status]" + errStr)
		PublishError(errStr, events.AUTOGENERATED)
	}
	log.Printf("Status retrieved, building events")

	//otherwise we need to have the service take the
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		errStr := fmt.Sprintf("There was a problem reading the response on a non-200 response: %v", err.Error())
		log.Printf("[api-status]" + errStr)
		PublishError(errStr, events.AUTOGENERATED)
		return err
	}

	var room base.PublicRoom

	err = json.Unmarshal(b, &room)
	if err != nil {
		errStr := fmt.Sprintf("There was a problem decoding the respone from the API: %s", err.Error())
		log.Printf("[api-status]" + errStr)
		PublishError(errStr, events.AUTOGENERATED)
		return err
	}
	log.Printf("Body unmarshalled")

	//now we take our list of devices and we build events
	et := events.CORESTATE
	ec := events.AUTOGENERATED
	ro := proom
	bu := pbuilding

	sentDevices := make(map[string]bool)
	log.Printf("[api-status] Iterating through displays")

	//Go through our displays first
	//there's probably a way to do this with reflection.
	for _, dev := range room.Displays {

		//adding stuff to support inter-room control
		name := ""
		id := ""
		if strings.Contains(dev.Name, "-") {
			//we assume the name is the deviceID
			id = dev.Name
			name = strings.Split(dev.Name, "-")[2]
		} else {
			name = dev.Name
			id = fmt.Sprintf("%v-%v-%v", bu, ro, name)
		}

		log.Printf("[api-status] Reporting for %v", dev.Name)
		err = SendEvent(et, ec, name, id, ro, bu, "power", dev.Power, false)
		if err != nil {
			log.Printf("[api-status] error sending error: %v", err)
			return err
		}
		err = SendEvent(et, ec, name, id, ro, bu, "input", dev.Input, false)
		if err != nil {
			log.Printf("[api-status] error sending error: %v", err)
			return err
		}
		if dev.Blanked != nil {
			err = SendEvent(et, ec, name, id, ro, bu, "blanked", fmt.Sprintf("%v", *dev.Blanked), false)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}

		}
		sentDevices[dev.Name] = true
	}

	//check audio devices
	log.Printf("[api-status] Done with displays, beginning audio devices")
	for _, dev := range room.AudioDevices {

		name := ""
		id := ""
		if strings.Contains(dev.Name, "-") {
			//we assume the name is the deviceID
			id = dev.Name
			name = strings.Split(dev.Name, "-")[2]
		} else {
			name = dev.Name
			id = fmt.Sprintf("%v-%v-%v", bu, ro, name)
		}

		log.Printf("[api-status] Reporting status for %v", dev.Name)
		if dev.Muted != nil {
			err = SendEvent(et, ec, name, id, ro, bu, "muted", fmt.Sprintf("%v", *dev.Muted), false)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
		}
		if dev.Volume != nil {
			err = SendEvent(et, ec, name, id, ro, bu, "volume", fmt.Sprintf("%v", *dev.Volume), false)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
		}

		//check to see if we already sent the common information
		if _, ok := sentDevices[dev.Name]; !ok {
			err = SendEvent(et, ec, name, id, ro, bu, "power", dev.Power, false)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
			err = SendEvent(et, ec, name, id, ro, bu, "input", dev.Input, false)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
		} else {
			log.Printf("[api-status] Device is also, display, skipping common values...")

		}
	}
	log.Printf("[api-status] Done with audio devices.")
	return nil
}

func ShouldIMonitorAPI() bool {
	resp, err := http.Get("http://localhost:8888/api")
	for err != nil {
		color.Set(color.FgRed)
		log.Printf("Error getting api host: %s", err)
		color.Unset()

		time.Sleep(time.Second * 7)
		resp, err = http.Get("http://localhost:8888/api")
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)

	var config uiconfig.APIHost
	json.Unmarshal(body, &config)

	// use config
	if len(config.Hostname) > 0 {
		if strings.Contains(config.Hostname, os.Getenv("SYSTEM_ID")) || strings.EqualFold(config.Hostname, "localhost") {
			return true
		}
		return false
	}
	return true
}
