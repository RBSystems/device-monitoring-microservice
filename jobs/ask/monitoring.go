package ask

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/byuoitav/av-api/base"
	"github.com/byuoitav/common/events"
	"github.com/byuoitav/common/log"
)

var (
	hostname = os.Getenv("PI_HOSTNAME")

	buildingID string
	roomID     string
	room       string
)

func init() {
	if len(hostname) == 0 {
		log.L.Fatalf("PI_HOSTNAME is not set.")
	}

	split := strings.Split(hostname, "-")
	if len(split) != 3 {
		log.L.Fatalf("invalid PI_HOSTNAME %v.", hostname)
	}

	buildingID = split[0]
	roomID = fmt.Sprintf("%v-%v", split[0], split[1])
	room = split[1]
}

// MonitoringJob is a jobe that gets the status of all the devices in the room, and pushes events from the status.
type MonitoringJob struct {
}

// Run runs the job.
func (m *MonitoringJob) Run(ctx interface{}, eventWrite chan events.Event) {
	log.SetLevel("debug")
	// get room status
	log.L.Infof("Getting room status")
	resp, err := http.Get(fmt.Sprintf("http://%v:8000/buildings/%v/rooms/%v", hostname, buildingID, room))
	if err != nil {
		log.L.Warnf("failed to get rooms status: %v", err)
		return
	}
	defer resp.Body.Close()

	// read the body
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.L.Warnf("failed to read API status response: %v", err)
		return
	}

	if resp.StatusCode/100 != 2 {
		log.L.Warnf("non 200 response recieved after querying API status: %s", b)
		return
	}

	var status base.PublicRoom
	err = json.Unmarshal(b, &status)
	if err != nil {
		log.L.Warnf("failed to unmarshal API status response: %v", err)
		return
	}
	log.L.Infof("Successfully got room status.")

	host, err := os.Hostname()
	if err != nil {
		host = hostname
	}

	sentDisplays := make(map[string]bool)
	event := events.Event{
		Hostname:         hostname,
		LocalEnvironment: true,
		Building:         buildingID,
		Room:             room,
		Event: events.EventInfo{
			Type:       events.CORESTATE,
			Requestor:  host,
			EventCause: events.AUTOGENERATED,
		},
	}

	// take the response and send events
	log.L.Debugf("Sending events for displays...")
	for _, dev := range status.Displays {
		event.Timestamp = time.Now().Format(time.RFC3339)

		if strings.Contains(dev.Name, "-") {
			// assume name is an ID
			event.Event.Device = strings.Split(dev.Name, "-")[2]
			event.Event.DeviceID = dev.Name
		} else {
			event.Event.Device = dev.Name
			event.Event.DeviceID = fmt.Sprintf("%v-%v-%v", buildingID, room, dev.Name)
		}

		log.L.Debugf("Reporting status of %v", event.Event.DeviceID)

		// report power status
		if len(dev.Power) > 0 {
			event.Event.EventInfoKey = "power"
			event.Event.EventInfoValue = dev.Power
			eventWrite <- event
		}

		// report input status
		if len(dev.Input) > 0 {
			event.Event.EventInfoKey = "input"
			event.Event.EventInfoValue = dev.Input
			eventWrite <- event
		}

		// report blanked status
		if dev.Blanked != nil {
			event.Event.EventInfoKey = "blanked"
			event.Event.EventInfoValue = fmt.Sprintf("%v", *dev.Blanked)
			eventWrite <- event
		}

		eventWrite <- event
		sentDisplays[dev.Name] = true
	}

	log.L.Debugf("Sending events for audio devices...")
	for _, dev := range status.AudioDevices {
		event.Timestamp = time.Now().Format(time.RFC3339)

		if strings.Contains(dev.Name, "-") {
			// assume name is an ID
			event.Event.Device = strings.Split(dev.Name, "-")[2]
			event.Event.DeviceID = dev.Name
		} else {
			event.Event.Device = dev.Name
			event.Event.DeviceID = fmt.Sprintf("%v-%v-%v", buildingID, room, dev.Name)
		}

		if dev.Muted != nil {
			event.Event.EventInfoKey = "muted"
			event.Event.EventInfoValue = fmt.Sprintf("%v", *dev.Muted)
			eventWrite <- event
		}

		if dev.Volume != nil {
			event.Event.EventInfoKey = "volume"
			event.Event.EventInfoValue = fmt.Sprintf("%v", *dev.Volume)
			eventWrite <- event
		}

		// send common info if it hasn't already been sent
		if _, ok := sentDisplays[dev.Name]; !ok {
			if len(dev.Power) > 0 {
				event.Event.EventInfoKey = "power"
				event.Event.EventInfoValue = dev.Power
				eventWrite <- event
			}

			if len(dev.Input) > 0 {
				event.Event.EventInfoKey = "input"
				event.Event.EventInfoValue = dev.Input
				eventWrite <- event
			}
		}
	}
}
