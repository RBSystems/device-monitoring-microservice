package ask

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"time"

	"github.com/byuoitav/av-api/base"
	"github.com/byuoitav/common/log"
	"github.com/byuoitav/common/v2/events"
	"github.com/byuoitav/device-monitoring-microservice/pi"
)

// MonitoringJob is a jobe that gets the status of all the devices in the room, and pushes events from the status
type MonitoringJob struct {
}

// Run runs the job.
func (m *MonitoringJob) Run(ctx interface{}, eventWrite chan events.Event) {
	log.L.Infof("Getting room status")

	split := strings.Split(pi.MustRoomID(), "-")
	resp, err := http.Get(fmt.Sprintf("http://localhost:8000/buildings/%v/rooms/%v", split[0], split[1]))
	if err != nil {
		log.L.Warnf("failed to get rooms status: %v", err)
		return
	}
	defer resp.Body.Close()

	// read the body
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.L.Warnf("failed to read API status response: %v", err)
		return
	}

	if resp.StatusCode/100 != 2 {
		log.L.Warnf("non 200 response recieved after querying API status: %s", b)
		return
	}

	var status base.PublicRoom
	err = json.Unmarshal(b, &status)
	if err != nil {
		log.L.Warnf("failed to unmarshal API status response: %v", err)
		return
	}

	log.L.Infof("Successfully got room status.")

	// build base event
	event := events.Event{
		GeneratingSystem: pi.MustHostname(),
		Timestamp:        time.Now(),
		EventTags: []string{
			events.CoreState,
			events.AutoGenerated,
		},
		TargetRoom: pi.MustRoomID(),

		// TODO switch events.BasicRoomInfo
		/*
			TargetRoom: events.BasicRoomInfo{
				BuildingID: pi.MustBuildingID(),
				RoomID:     pi.MustRoomID(),
			},
		*/
	}

	sentDisplays := make(map[string]bool)

	// take the response and send events
	log.L.Debugf("Sending events for displays...")
	for _, dev := range status.Displays {
		if strings.Contains(dev.Name, "-") {
			event.TargetDevice = events.GenerateBasicDeviceInfo(dev.Name)
		} else {
			event.TargetDevice = events.GenerateBasicDeviceInfo(fmt.Sprintf("%v-%v", pi.MustRoomID(), dev.Name))
		}

		log.L.Debugf("Reporting status of %v", event.TargetDevice.DeviceID)

		// report power status
		if len(dev.Power) > 0 {
			event.Key = "power"
			event.Value = dev.Power
			eventWrite <- event
		}

		// report input status
		if len(dev.Input) > 0 {
			event.Key = "input"
			event.Value = dev.Input
			eventWrite <- event
		}

		// report blanked status
		if dev.Blanked != nil {
			event.Key = "blanked"
			event.Value = fmt.Sprintf("%v", *dev.Blanked)
			eventWrite <- event
		}

		sentDisplays[dev.Name] = true
	}

	log.L.Debugf("Sending events for audio devices...")
	for _, dev := range status.AudioDevices {
		if strings.Contains(dev.Name, "-") {
			event.TargetDevice = events.GenerateBasicDeviceInfo(dev.Name)
		} else {
			event.TargetDevice = events.GenerateBasicDeviceInfo(fmt.Sprintf("%v-%v", pi.MustRoomID(), dev.Name))
		}

		if dev.Muted != nil {
			event.Key = "muted"
			event.Value = fmt.Sprintf("%v", *dev.Muted)
			eventWrite <- event
		}

		if dev.Volume != nil {
			event.Key = "volume"
			event.Value = fmt.Sprintf("%v", *dev.Volume)
			eventWrite <- event
		}

		// send common info if it hasn't already been sent
		if _, ok := sentDisplays[dev.Name]; !ok {
			if len(dev.Power) > 0 {
				event.Key = "power"
				event.Value = dev.Power
				eventWrite <- event
			}

			if len(dev.Input) > 0 {
				event.Key = "input"
				event.Value = dev.Input
				eventWrite <- event
			}
		}
	}
}
