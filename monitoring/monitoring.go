package monitoring

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/byuoitav/av-api/base"
	"github.com/byuoitav/common/events"
	"github.com/byuoitav/touchpanel-ui-microservice/uiconfig"
	"github.com/fatih/color"
)

var eventnode *events.EventNode
var ticker time.Ticker

//StartMonitoring will start a routine that will periodically query the apiAddr, building, and room.
//The responses will be decoded into the state variables and reported to the elk stack as CORESTATE events, with AUTOGENERATED cause
func StartMonitoring(interval time.Duration, apiAddr string, building string, room string, en *events.EventNode) string {
	eventnode = en
	addr := fmt.Sprintf("http://%s/buildings/%s/rooms/%s", apiAddr, building, room)
	ticker := time.NewTicker(interval)

	go func() {
		for _ = range ticker.C {
			log.Printf("[api-status] Getting and reporting status to %v", addr)
			err := GetAndReportStatus(addr, building, room)
			if err != nil {
				log.Printf("[api-status] Error reporting the status: %v", err.Error())
			}
			log.Printf("[api-status] Done.")
		}
	}()

	return addr
}
func StopMonitoring() {
	ticker.Stop()
}

func GetAndReportStatus(addr string, pbuilding string, proom string) error {
	log.Printf("[api-status] Getting status...")
	resp, err := http.Get(addr)
	if err != nil {
		errStr := fmt.Sprintf("There was a problem getting the response while querying room status: %v", err.Error())
		log.Printf("[api-status]" + errStr)
		PublishError(errStr, events.AUTOGENERATED)
		return err
	}

	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		b, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			errStr := fmt.Sprintf("There was a problem reading the response on a non-200 response: %v", err.Error())
			log.Printf("[api-status]" + errStr)
			PublishError(errStr, events.AUTOGENERATED)
			return err
		}
		errStr := fmt.Sprintf("Non 200 response recieved: %s", b)
		log.Printf("[api-status]" + errStr)
		PublishError(errStr, events.AUTOGENERATED)
	}
	log.Printf("Status retrieved, building events")

	//otherwise we need to have the service take the
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		errStr := fmt.Sprintf("There was a problem reading the response on a non-200 response: %v", err.Error())
		log.Printf("[api-status]" + errStr)
		PublishError(errStr, events.AUTOGENERATED)
		return err
	}

	var room base.PublicRoom

	err = json.Unmarshal(b, &room)
	if err != nil {
		errStr := fmt.Sprintf("There was a problem decoding the respone from the API: %s", err.Error())
		log.Printf("[api-status]" + errStr)
		PublishError(errStr, events.AUTOGENERATED)
		return err
	}
	log.Printf("Body unmarshalled")

	//now we take our list of devices and we build events
	et := events.CORESTATE
	ec := events.AUTOGENERATED
	ro := proom
	bu := pbuilding

	sentDevices := make(map[string]bool)
	log.Printf("[api-status] Iterating through displays")

	//Go through our displays first
	//there's probably a way to do this with reflection.
	for _, dev := range room.Displays {
		log.Printf("[api-status] Reporting for %v", dev.Name)
		err = SendEvent(et, ec, dev.Name, ro, bu, "power", dev.Power, false)
		if err != nil {
			log.Printf("[api-status] error sending error: %v", err)
			return err
		}
		err = SendEvent(et, ec, dev.Name, ro, bu, "input", dev.Input, false)
		if err != nil {
			log.Printf("[api-status] error sending error: %v", err)
			return err
		}
		if dev.Blanked != nil {
			err = SendEvent(et, ec, dev.Name, ro, bu, "blanked", fmt.Sprintf("%v", *dev.Blanked), false)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}

		}
		sentDevices[dev.Name] = true
	}

	//check audio devices
	log.Printf("[api-status] Done with displays, beginning audio devices")
	for _, dev := range room.AudioDevices {
		log.Printf("[api-status] Reporting status for %v", dev.Name)
		if dev.Muted != nil {
			err = SendEvent(et, ec, dev.Name, ro, bu, "muted", fmt.Sprintf("%v", *dev.Muted), false)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
		}
		if dev.Volume != nil {
			err = SendEvent(et, ec, dev.Name, ro, bu, "volume", fmt.Sprintf("%v", *dev.Volume), false)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
		}

		//check to see if we already sent the common information
		if _, ok := sentDevices[dev.Name]; !ok {
			err = SendEvent(et, ec, dev.Name, ro, bu, "power", dev.Power, false)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
			err = SendEvent(et, ec, dev.Name, ro, bu, "input", dev.Input, false)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
		} else {
			log.Printf("[api-status] Device is also, display, skipping common values...")

		}
	}
	log.Printf("[api-status] Done with audio devices.")
	return nil
}

func ShouldIMonitorAPI() bool {
	resp, err := http.Get("http://localhost:8888/api")
	for err != nil {
		color.Set(color.FgRed)
		log.Printf("Error getting api host: %s", err)
		color.Unset()

		time.Sleep(time.Second * 7)
		resp, err = http.Get("http://localhost:8888/api")
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)

	var config uiconfig.APIHost
	json.Unmarshal(body, &config)

	// use config
	if len(config.Hostname) > 0 {
		if strings.Contains(config.Hostname, os.Getenv("PI_HOSTNAME")) || strings.EqualFold(config.Hostname, "localhost") {
			return true
		}
		return false
	}
	return true
}
