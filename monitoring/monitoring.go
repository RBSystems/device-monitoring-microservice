package monitoring

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"
	"time"

	"github.com/byuoitav/av-api/base"
	"github.com/byuoitav/central-event-system/messenger"
	"github.com/byuoitav/common/v2/events"
	"github.com/byuoitav/touchpanel-ui-microservice/uiconfig"
	"github.com/fatih/color"
)

var m *messenger.Messenger

//var eventnode *events.EventNode
var ticker time.Ticker

//StartMonitoring will start a routine that will periodically query the apiAddr, building, and room.
//The responses will be decoded into the state variables and reported to the elk stack as CORESTATE events, with AUTOGENERATED cause
func StartMonitoring(interval time.Duration, apiAddr string, building string, room string, mess *messenger.Messenger) string {

	//This code is a "mess" hahaha, but naming problems are real.
	m = mess
	addr := fmt.Sprintf("http://%s/buildings/%s/rooms/%s", apiAddr, building, room)
	ticker := time.NewTicker(interval)

	go func() {
		for _ = range ticker.C {
			log.Printf("[api-status] Getting and reporting status to %v", addr)
			err := GetAndReportStatus(addr, building, room)
			if err != nil {
				log.Printf("[api-status] Error reporting the status: %v", err.Error())
			}
			log.Printf("[api-status] Done.")
		}
	}()

	return addr
}
func StopMonitoring() {
	ticker.Stop()
}

func GetAndReportStatus(addr string, pbuilding string, proom string) error {
	log.Printf("[api-status] Getting status...")
	resp, err := http.Get(addr)
	if err != nil {
		errStr := fmt.Sprintf("There was a problem getting the response while querying room status: %v", err.Error())
		log.Printf("[api-status]" + errStr)
		PublishError(errStr)
		return err
	}

	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		b, err := ioutil.ReadAll(resp.Body)
		if err != nil {
			errStr := fmt.Sprintf("There was a problem reading the response on a non-200 response: %v", err.Error())
			log.Printf("[api-status]" + errStr)
			PublishError(errStr)
			return err
		}
		errStr := fmt.Sprintf("Non 200 response recieved: %s", b)
		log.Printf("[api-status]" + errStr)
		PublishError(errStr)
	}
	log.Printf("Status retrieved, building events")

	//otherwise we need to have the service take the
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		errStr := fmt.Sprintf("There was a problem reading the response on a non-200 response: %v", err.Error())
		log.Printf("[api-status]" + errStr)
		PublishError(errStr)
		return err
	}

	var room base.PublicRoom

	err = json.Unmarshal(b, &room)
	if err != nil {
		errStr := fmt.Sprintf("There was a problem decoding the respone from the API: %s", err.Error())
		log.Printf("[api-status]" + errStr)
		PublishError(errStr)
		return err
	}
	log.Printf("Body unmarshalled")

	//now we take our list of devices and we build events
	ro := proom
	bu := pbuilding

	sentDevices := make(map[string]bool)
	log.Printf("[api-status] Iterating through displays")

	//Go through our displays first
	//there's probably a way to do this with reflection.
	for _, dev := range room.Displays {

		//adding stuff to support inter-room control
		name := ""
		id := ""
		if strings.Contains(dev.Name, "-") {
			//we assume the name is the deviceID
			id = dev.Name
			name = strings.Split(dev.Name, "-")[2]
		} else {
			name = dev.Name
			id = fmt.Sprintf("%v-%v-%v", bu, ro, name)
		}

		log.Printf("[api-status] Reporting for %v", dev.Name)
		powerE := events.Event{
			AffectedRoom: events.GenerateBasicRoomInfo(fmt.Sprintf("%s-%s", bu, ro)),
			TargetDevice: events.GenerateBasicDeviceInfo(id),
			Key:          "power",
			Value:        dev.Power,
		}
		powerE.AddToTags(events.CoreState, events.AutoGenerated)
		err = Publish(powerE)
		if err != nil {
			log.Printf("[api-status] error sending error: %v", err)
			return err
		}

		inputE := events.Event{
			AffectedRoom: events.GenerateBasicRoomInfo(fmt.Sprintf("%s-%s", bu, ro)),
			TargetDevice: events.GenerateBasicDeviceInfo(id),
			Key:          "input",
			Value:        dev.Input,
		}
		inputE.AddToTags(events.CoreState, events.AutoGenerated)
		err = Publish(inputE)
		if err != nil {
			log.Printf("[api-status] error sending error: %v", err)
			return err
		}

		if dev.Blanked != nil {
			blankedE := events.Event{
				AffectedRoom: events.GenerateBasicRoomInfo(fmt.Sprintf("%s-%s", bu, ro)),
				TargetDevice: events.GenerateBasicDeviceInfo(id),
				Key:          "blanked",
				Value:        fmt.Sprintf("%v", *dev.Blanked),
			}
			blankedE.AddToTags(events.CoreState, events.AutoGenerated)
			err = Publish(blankedE)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
		}
		sentDevices[dev.Name] = true
	}

	//check audio devices
	log.Printf("[api-status] Done with displays, beginning audio devices")
	for _, dev := range room.AudioDevices {

		name := ""
		id := ""
		if strings.Contains(dev.Name, "-") {
			//we assume the name is the deviceID
			id = dev.Name
			name = strings.Split(dev.Name, "-")[2]
		} else {
			name = dev.Name
			id = fmt.Sprintf("%v-%v-%v", bu, ro, name)
		}

		log.Printf("[api-status] Reporting status for %v", dev.Name)

		if dev.Muted != nil {
			mutedE := events.Event{
				AffectedRoom: events.GenerateBasicRoomInfo(fmt.Sprintf("%s-%s", bu, ro)),
				TargetDevice: events.GenerateBasicDeviceInfo(id),
				Key:          "muted",
				Value:        fmt.Sprintf("%v", *dev.Muted),
			}
			mutedE.AddToTags(events.CoreState, events.AutoGenerated)
			err = Publish(mutedE)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
		}
		if dev.Volume != nil {
			volumeE := events.Event{
				AffectedRoom: events.GenerateBasicRoomInfo(fmt.Sprintf("%s-%s", bu, ro)),
				TargetDevice: events.GenerateBasicDeviceInfo(id),
				Key:          "volume",
				Value:        fmt.Sprintf("%v", *dev.Volume),
			}
			volumeE.AddToTags(events.CoreState, events.AutoGenerated)
			err = Publish(volumeE)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}
		}

		//check to see if we already sent the common information
		if _, ok := sentDevices[dev.Name]; !ok {

			powerE := events.Event{
				AffectedRoom: events.GenerateBasicRoomInfo(fmt.Sprintf("%s-%s", bu, ro)),
				TargetDevice: events.GenerateBasicDeviceInfo(id),
				Key:          "power",
				Value:        dev.Power,
			}
			powerE.AddToTags(events.CoreState, events.AutoGenerated)
			err = Publish(powerE)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}

			inputE := events.Event{
				AffectedRoom: events.GenerateBasicRoomInfo(fmt.Sprintf("%s-%s", bu, ro)),
				TargetDevice: events.GenerateBasicDeviceInfo(id),
				Key:          "input",
				Value:        dev.Input,
			}
			inputE.AddToTags(events.CoreState, events.AutoGenerated)
			err = Publish(inputE)
			if err != nil {
				log.Printf("[api-status] error sending error: %v", err)
				return err
			}

		} else {
			log.Printf("[api-status] Device is also, display, skipping common values...")

		}
	}
	log.Printf("[api-status] Done with audio devices.")
	return nil
}

func ShouldIMonitorAPI() bool {
	resp, err := http.Get("http://localhost:8888/api")
	for err != nil {
		color.Set(color.FgRed)
		log.Printf("Error getting api host: %s", err)
		color.Unset()

		time.Sleep(time.Second * 7)
		resp, err = http.Get("http://localhost:8888/api")
	}
	defer resp.Body.Close()
	body, _ := ioutil.ReadAll(resp.Body)

	var config uiconfig.APIHost
	json.Unmarshal(body, &config)

	// use config
	if len(config.Hostname) > 0 {
		if strings.Contains(config.Hostname, os.Getenv("SYSTEM_ID")) || strings.EqualFold(config.Hostname, "localhost") {
			return true
		}
		return false
	}
	return true
}
